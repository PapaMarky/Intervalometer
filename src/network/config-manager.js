import { readFile, writeFile, access, constants, mkdir } from 'fs/promises';
import { dirname } from 'path';
import { logger } from '../utils/logger.js';

/**
 * Centralized Network Configuration Management
 * Single source of truth for generating network configuration files
 * Eliminates duplicate config templates scattered across scripts
 */
export class NetworkConfigManager {
  constructor() {
    // Configuration templates and current values
    this.configs = {
      hostapd: {
        template: null,
        current: null,
        path: '/etc/hostapd/hostapd.conf'
      },
      dnsmasq: {
        template: null,
        current: null,
        path: '/etc/dnsmasq.conf'
      },
      dhcpcd: {
        template: null,
        current: null,
        path: '/etc/dhcpcd.conf'
      }
    };
    
    // Default configuration values
    this.defaults = {
      accessPoint: {
        ssid: 'PiCameraController',
        passphrase: 'camera123',
        channel: 7,
        hidden: false,
        interface: 'ap0',
        ipAddress: '192.168.4.1',
        ipRange: '192.168.4.2,192.168.4.20'
      },
      wifiClient: {
        interface: 'wlan0',
        country: 'US'
      }
    };
    
    // Backup file suffix
    this.backupSuffix = '.pi-camera-control.backup';
  }
  
  /**
   * Initialize configuration manager
   */
  async initialize() {
    try {
      logger.info('Initializing NetworkConfigManager...');
      
      // Load current configurations
      await this.loadCurrentConfigs();
      
      // Generate default templates
      this.generateTemplates();
      
      logger.info('NetworkConfigManager initialized successfully');
      return true;
      
    } catch (error) {
      logger.error('NetworkConfigManager initialization failed:', error);
      throw error;
    }
  }
  
  /**
   * Load current configuration files
   */
  async loadCurrentConfigs() {
    for (const [name, config] of Object.entries(this.configs)) {
      try {
        await access(config.path, constants.R_OK);
        config.current = await readFile(config.path, 'utf8');
        logger.debug(`Loaded current ${name} configuration`);
      } catch (error) {
        logger.debug(`Current ${name} configuration not found or not readable`);
        config.current = null;
      }
    }
  }
  
  /**
   * Generate configuration templates
   */
  generateTemplates() {
    this.configs.hostapd.template = this.generateHostapdTemplate();
    this.configs.dnsmasq.template = this.generateDnsmasqTemplate();
    this.configs.dhcpcd.template = this.generateDhcpcdTemplate();
  }
  
  /**
   * Generate hostapd configuration template
   */
  generateHostapdTemplate(options = {}) {
    const config = { ...this.defaults.accessPoint, ...options };
    
    return `# Pi Camera Control Access Point Configuration
# Generated by NetworkConfigManager

# Basic interface configuration
interface=${config.interface}
driver=nl80211

# Network settings
ssid=${config.ssid}
hw_mode=g
channel=${config.channel}
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=${config.hidden ? '1' : '0'}

# Security configuration
wpa=2
wpa_passphrase=${config.passphrase}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP

# Performance settings
max_num_sta=10
wpa_group_rekey=86400
`;
  }
  
  /**
   * Generate dnsmasq configuration template
   */
  generateDnsmasqTemplate(options = {}) {
    const config = { ...this.defaults.accessPoint, ...options };
    
    return `# Pi Camera Control dnsmasq Configuration
# Generated by NetworkConfigManager

# Basic configuration
interface=${config.interface}
bind-interfaces

# DHCP configuration for AP clients
dhcp-range=${config.ipRange},255.255.255.0,24h
dhcp-option=option:router,${config.ipAddress}
dhcp-option=option:dns-server,${config.ipAddress}

# DNS configuration
address=/#/${config.ipAddress}
address=/picontrol.local/${config.ipAddress}
address=/camera.local/${config.ipAddress}
address=/pi-camera-control.local/${config.ipAddress}

# Disable DNS forwarding for local-only operation
no-resolv
server=8.8.8.8
server=8.8.4.4

# Logging (comment out for production)
# log-queries
# log-dhcp

# Cache settings
cache-size=1000
neg-ttl=60
`;
  }
  
  /**
   * Generate dhcpcd configuration template for AP interface
   */
  generateDhcpcdTemplate(options = {}) {
    const config = { ...this.defaults.accessPoint, ...options };
    
    return `
# Pi Camera Control AP configuration
# Generated by NetworkConfigManager
interface ${config.interface}
static ip_address=${config.ipAddress}/24
nohook wpa_supplicant
`;
  }
  
  /**
   * Ensure access point configuration is present and up to date
   */
  async ensureAccessPointConfig(options = {}) {
    try {
      logger.info('Ensuring access point configuration...');
      
      const config = { ...this.defaults.accessPoint, ...options };
      
      // Generate configurations with current options
      const hostapdConfig = this.generateHostapdTemplate(config);
      const dnsmasqConfig = this.generateDnsmasqTemplate(config);
      
      // Update hostapd configuration
      await this.updateConfigFile('hostapd', hostapdConfig);
      
      // Update dnsmasq configuration
      await this.updateConfigFile('dnsmasq', dnsmasqConfig);
      
      // Update dhcpcd configuration (append AP section if not present)
      await this.updateDhcpcdForAP(config);
      
      // Update daemon configuration
      await this.updateHostapdDaemon();
      
      logger.info('Access point configuration ensured');
      
    } catch (error) {
      logger.error('Failed to ensure access point configuration:', error);
      throw error;
    }
  }
  
  /**
   * Ensure WiFi client configuration
   */
  async ensureWiFiClientConfig(options = {}) {
    try {
      logger.info('Ensuring WiFi client configuration...');
      
      const config = { ...this.defaults.wifiClient, ...options };
      
      // Ensure wpa_supplicant configuration exists
      await this.ensureWpaSupplicantConfig(config);
      
      logger.info('WiFi client configuration ensured');
      
    } catch (error) {
      logger.error('Failed to ensure WiFi client configuration:', error);
      throw error;
    }
  }
  
  /**
   * Update configuration file with backup
   */
  async updateConfigFile(configName, newContent) {
    const config = this.configs[configName];
    if (!config) {
      throw new Error(`Unknown configuration: ${configName}`);
    }
    
    try {
      // Create backup if original file exists and we haven't backed it up yet
      const backupPath = `${config.path}${this.backupSuffix}`;
      
      try {
        await access(config.path, constants.R_OK);
        // File exists, check if we need to back it up
        try {
          await access(backupPath, constants.R_OK);
          // Backup already exists
        } catch {
          // Create backup
          const originalContent = await readFile(config.path, 'utf8');
          await writeFile(backupPath, originalContent, 'utf8');
          logger.info(`Created backup: ${backupPath}`);
        }
      } catch {
        // Original file doesn't exist, no backup needed
      }
      
      // Ensure directory exists
      const dir = dirname(config.path);
      await mkdir(dir, { recursive: true });
      
      // Write new configuration
      await writeFile(config.path, newContent, 'utf8');
      config.current = newContent;
      
      logger.info(`Updated ${configName} configuration: ${config.path}`);
      
    } catch (error) {
      logger.error(`Failed to update ${configName} configuration:`, error);
      throw error;
    }
  }
  
  /**
   * Update dhcpcd configuration for AP interface
   */
  async updateDhcpcdForAP(apConfig) {
    const dhcpcdPath = '/etc/dhcpcd.conf';
    const apSection = this.generateDhcpcdTemplate(apConfig);
    
    try {
      let dhcpcdContent = '';
      
      try {
        dhcpcdContent = await readFile(dhcpcdPath, 'utf8');
      } catch {
        // File doesn't exist, create new
        logger.info('dhcpcd.conf not found, creating new one');
      }
      
      // Check if AP section already exists
      if (dhcpcdContent.includes(`interface ${apConfig.interface}`)) {
        logger.debug('AP interface already configured in dhcpcd.conf');
        return;
      }
      
      // Append AP configuration
      const updatedContent = dhcpcdContent + apSection;
      
      // Create backup if content exists
      if (dhcpcdContent.length > 0) {
        const backupPath = `${dhcpcdPath}${this.backupSuffix}`;
        try {
          await access(backupPath, constants.R_OK);
        } catch {
          await writeFile(backupPath, dhcpcdContent, 'utf8');
          logger.info(`Created dhcpcd.conf backup: ${backupPath}`);
        }
      }
      
      // Write updated configuration
      await writeFile(dhcpcdPath, updatedContent, 'utf8');
      logger.info('Updated dhcpcd.conf with AP configuration');
      
    } catch (error) {
      logger.error('Failed to update dhcpcd configuration:', error);
      throw error;
    }
  }
  
  /**
   * Update hostapd daemon configuration
   */
  async updateHostapdDaemon() {
    const daemonPath = '/etc/default/hostapd';
    const configLine = 'DAEMON_CONF="/etc/hostapd/hostapd.conf"';
    
    try {
      let daemonContent = '';
      
      try {
        daemonContent = await readFile(daemonPath, 'utf8');
      } catch {
        // File doesn't exist, create new
        daemonContent = `# Defaults for hostapd initscript\n`;
      }
      
      // Check if configuration is already set
      if (daemonContent.includes('DAEMON_CONF="/etc/hostapd/hostapd.conf"')) {
        logger.debug('hostapd daemon already configured');
        return;
      }
      
      // Update or add configuration
      let updatedContent;
      if (daemonContent.includes('#DAEMON_CONF=""')) {
        // Replace commented line
        updatedContent = daemonContent.replace(/#DAEMON_CONF=""/, configLine);
      } else if (daemonContent.includes('DAEMON_CONF=')) {
        // Replace existing line
        updatedContent = daemonContent.replace(/^DAEMON_CONF=.*$/m, configLine);
      } else {
        // Add new line
        updatedContent = daemonContent + `\n${configLine}\n`;
      }
      
      await writeFile(daemonPath, updatedContent, 'utf8');
      logger.info('Updated hostapd daemon configuration');
      
    } catch (error) {
      logger.error('Failed to update hostapd daemon configuration:', error);
      // Don't throw - this is not critical
    }
  }
  
  /**
   * Ensure wpa_supplicant configuration exists
   */
  async ensureWpaSupplicantConfig(clientConfig) {
    const wpaPath = '/etc/wpa_supplicant/wpa_supplicant.conf';
    
    try {
      let wpaContent = '';
      
      try {
        wpaContent = await readFile(wpaPath, 'utf8');
      } catch {
        // File doesn't exist, create minimal configuration
        wpaContent = `# Pi Camera Control wpa_supplicant configuration
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=${clientConfig.country}

`;
      }
      
      // Ensure country is set
      if (!wpaContent.includes('country=')) {
        wpaContent = `country=${clientConfig.country}\n${wpaContent}`;
        await writeFile(wpaPath, wpaContent, 'utf8');
        logger.info('Updated wpa_supplicant with country setting');
      }
      
    } catch (error) {
      logger.error('Failed to ensure wpa_supplicant configuration:', error);
      // Don't throw - wpa_supplicant can work without this file
    }
  }
  
  /**
   * Update access point configuration with new settings
   */
  async updateAccessPointConfig(newConfig) {
    const updatedConfig = { ...this.defaults.accessPoint, ...newConfig };
    await this.ensureAccessPointConfig(updatedConfig);
  }
  
  /**
   * Get current configuration values
   */
  getCurrentConfig(configName) {
    const config = this.configs[configName];
    return config ? config.current : null;
  }
  
  /**
   * Get default configuration values
   */
  getDefaults() {
    return JSON.parse(JSON.stringify(this.defaults));
  }
  
  /**
   * Cleanup resources
   */
  async cleanup() {
    logger.info('NetworkConfigManager cleanup complete');
  }
}